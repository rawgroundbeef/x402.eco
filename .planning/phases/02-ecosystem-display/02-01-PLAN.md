---
phase: 02-ecosystem-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/EcosystemSection.tsx
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Client-Side Integrations category displays entries from JSON files"
    - "Services & Endpoints category displays entries from JSON files"
    - "Infrastructure & Tooling category displays entries from JSON files"
    - "Learning & Community category displays entries from JSON files"
    - "Ecosystem grid loads data at build time (no client-side fetch)"
  artifacts:
    - path: "components/EcosystemSection.tsx"
      provides: "Server component that renders ecosystem grid from JSON data"
      min_lines: 50
    - path: "app/page.tsx"
      provides: "Page using EcosystemSection component"
      contains: "EcosystemSection"
  key_links:
    - from: "components/EcosystemSection.tsx"
      to: "lib/ecosystem.ts"
      via: "import getEntriesByCategory"
      pattern: "getEntriesByCategory|getEcosystemByCategory"
    - from: "components/EcosystemSection.tsx"
      to: "lib/types/ecosystem.ts"
      via: "import CATEGORIES"
      pattern: "CATEGORIES"
    - from: "app/page.tsx"
      to: "components/EcosystemSection.tsx"
      via: "component import and render"
      pattern: "EcosystemSection"
---

<objective>
Integrate file-based ecosystem data into the UI by creating a server component that loads JSON entries at build time.

Purpose: Connect Phase 1's data layer to the existing UI, replacing hardcoded ecosystem data with file-based entries. This enables the PR-submittable ecosystem directory.

Output: EcosystemSection.tsx server component, updated page.tsx that renders JSON-based entries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-structure/01-01-SUMMARY.md
@.planning/phases/01-data-structure/01-02-SUMMARY.md
@lib/types/ecosystem.ts
@lib/ecosystem.ts
@app/page.tsx (lines 468-553 - ecosystem section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EcosystemSection server component</name>
  <files>components/EcosystemSection.tsx</files>
  <action>
Create a server component that:

1. Imports from lib/ecosystem.ts: `getEntriesByCategory`
2. Imports from lib/types: `CATEGORIES`, `EcosystemEntry`, `CategorySlug`
3. Imports FadeIn components from components/FadeIn.tsx

4. Creates a server component (NO "use client" directive) named `EcosystemSection`:
   - Loads entries for each category using getEntriesByCategory()
   - Builds a structure similar to the old ecosystem array but with real data
   - Renders the same visual structure as current page.tsx lines 468-553

5. Visual structure to replicate:
   - Section with id="ecosystem" and scroll-mt-16
   - Header with "Who's Building" title and description
   - FadeInStagger grid (md:grid-cols-2 lg:grid-cols-3)
   - For each category in CATEGORIES:
     - FadeInStaggerItem containing:
       - Category title (h3, uppercase, tracking-wide)
       - Entry cards in space-y-3 div
   - Each entry card is an <a> link with:
     - bg-card border border-border rounded-xl card-hover
     - Entry name (h4), description (p), external link icon
   - Footer with "View Full Directory" link to x402.org

6. Handle empty categories gracefully (skip if no entries)

Note: The component must be a server component to use fs-based data loading. The FadeIn components are client components but can be used in server components - they'll hydrate on the client.
  </action>
  <verify>
Run: `pnpm exec tsc --noEmit`
Verify: No TypeScript errors
  </verify>
  <done>
EcosystemSection.tsx exists, exports default function, imports from lib/ecosystem.ts, uses CATEGORIES for iteration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update page.tsx to use EcosystemSection</name>
  <files>app/page.tsx</files>
  <action>
Modify app/page.tsx to use the new server component:

1. Remove the `ecosystem` import from @/lib/data (line 16 area)
   - Keep all other imports from lib/data (stats, facilitators, servers, resources, educationalContent)

2. Import the new EcosystemSection component:
   ```typescript
   import { EcosystemSection } from "@/components/EcosystemSection";
   ```

3. Replace the entire SECTION 4: ECOSYSTEM block (lines ~468-553) with:
   ```tsx
   {/* ============================================ */}
   {/* SECTION 4: ECOSYSTEM */}
   {/* ============================================ */}
   <EcosystemSection />
   ```

4. The page can remain "use client" because:
   - EcosystemSection is a server component imported into a client component
   - Next.js handles this composition correctly - the server component renders on server, client components hydrate
   - Actually, we need to reconsider: "use client" pages cannot import server components directly

CORRECTION: Since page.tsx is a client component, we have two options:
   A) Make page.tsx a server component (remove "use client") and wrap interactive parts in client components
   B) Pre-load data and pass as props

Option A is cleaner. Update approach:
   - Remove "use client" from page.tsx
   - Create a new client component for interactive parts (dialog state, facilitator selection)
   - Keep EcosystemSection as server component

Actually simpler approach for this iteration:
   - Load ecosystem data at the top of page.tsx using the data loader
   - BUT: page.tsx is "use client", can't use fs

Best approach for minimal changes:
   - Create EcosystemSection as server component
   - Make page.tsx a server component
   - Extract client-interactive parts (useState hooks) into a new ClientInteractive component
   - OR: Just inline the ecosystem render in page.tsx after making it a server component

Final decision - most minimal approach:
   - Convert page.tsx to server component
   - Extract the parts that need useState (dialog, facilitator selection) into a client component
   - Import EcosystemSection into server page.tsx

Steps:
1. Create components/HomeClient.tsx - client component with all the interactive state (dialog, facilitator)
2. Update page.tsx:
   - Remove "use client"
   - Load ecosystem data using getEntriesByCategory
   - Render EcosystemSection inline or as separate component
   - Wrap interactive sections with HomeClient
  </action>
  <verify>
Run: `pnpm run build`
Verify: Build succeeds with no errors

Run: `pnpm run dev` then visit http://localhost:3000
Verify: Ecosystem section displays all 4 categories with entries from JSON files
  </verify>
  <done>
- page.tsx is a server component (no "use client")
- Ecosystem section renders entries from JSON files
- All 12 entries display across 4 categories
- Interactive features (dialogs, facilitator selection) still work
  </done>
</task>

<task type="auto">
  <name>Task 3: Create HomeClient for interactive state</name>
  <files>components/HomeClient.tsx</files>
  <action>
Create a client component that handles all interactive state from the home page:

1. Add "use client" directive

2. Move these pieces from page.tsx into HomeClient:
   - useState for dialogOpen
   - useState for featuredFacilitator
   - openDialog and closeDialog functions
   - The EducationalDialog component render
   - The sections that use featuredFacilitator (facilitators section)

3. Export HomeClient component that wraps:
   - Educational dialog
   - Facilitators section (with chart and cards)
   - Any other sections using useState

4. Accept props for static data:
   - facilitators array
   - educationalContent object

This allows page.tsx to be a server component while preserving client interactivity.

Note: The Servers section, Resources section, Hero section can remain in the server component since they have no client state.
  </action>
  <verify>
Run: `pnpm exec tsc --noEmit`
Verify: No TypeScript errors
  </verify>
  <done>
HomeClient.tsx exists with "use client", contains useState hooks and interactive sections, accepts facilitators and educationalContent as props.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   pnpm run build
   ```
   Must complete without errors.

2. **Runtime verification:**
   ```bash
   pnpm run dev
   ```
   Visit http://localhost:3000#ecosystem

3. **Category verification:**
   - Client-Side Integrations shows: x402-fetch, LangChain x402, AgentKit
   - Services & Endpoints shows: x402jobs, Memeputer, AgentCloud
   - Infrastructure & Tooling shows: OpenFacilitator, x402-server, x402scan
   - Learning & Community shows: x402.org, Agent Builders Club, Whitepaper

4. **Link verification:**
   - Click any entry - should open correct external URL

5. **Interactive features verification:**
   - Educational dialogs still work
   - Facilitator selection and chart still work
</verification>

<success_criteria>
- [ ] Build completes without errors
- [ ] All 4 ecosystem categories display
- [ ] All 12 JSON entries render correctly
- [ ] Entry links work (open external URLs)
- [ ] Educational dialogs work
- [ ] Facilitator chart/selection works
- [ ] No visual regressions in other sections
</success_criteria>

<output>
After completion, create `.planning/phases/02-ecosystem-display/02-01-SUMMARY.md`
</output>
